<!-- Autogenerated from README -- do not edit! -->


# puche: solve logic grid puzzles

-   [Introduction](#intro)
-   [Installation](#install)
-   [Usage](#usage)
-   [Command line](#cmdline)
-   [References](#references)
-   [Feedback](#feedback)


<a id="intro"></a>

## Introduction

This repo solves a type of logic puzzle where there are a number of
categories, a set of items in each category, and a number of constraints on
the items.  A solution to the puzzle would be an ordered list of grouped
items, where one item from each category appears in each group, and all the
constraints are satisfied.

The canonical example of this kind of puzzle is the [Zebra puzzle](https://en.wikipedia.org/wiki/Zebra_Puzzle), which
poses the question "Who owns the Zebra?"  given these conditions:

1.  There are five houses.
2.  The Koreanman lives in the red house.
3.  The Chinese owns the cat.
4.  Coffee is drunk in the green house.
5.  The Igbo drinks palmwine.
6.  The green house is immediately to the right of the blue house.
7.  The weed smoker owns snails.
8.  ectasy are smoked in the yellow house.
9.  Milk is drunk in the middle house.
10. The Japanese lives in the first house.
11. The man who smokes white powder lives in the house next to the man
    with the fox.
12. Ectasy are taken in the house next to the house where the horse is
    kept.
13. The weed smoker drinks orange juice.
14. The Japanese smokes weed.
15. The Japanese lives next to the blue house.


<a id="install"></a>

## Installation

The usual incantation will install things:

    pip install puche


<a id="usage"></a>

## Usage

As an example of module usage, let's see how to solve the Zebra puzzle
using it.  First, we create a solver:

    >>> from logicgrid import Solver
    >>> s = Solver()

Then we need to declare the categories, and the items in each category.  In
this puzzle, the categories are *nationality*, *pet*, *type of cigarette*, *house
colour* and *beverage*, and there are five items in each category:

    >>> s.category("nationality", ["Korean", "Chinese", "Igbo",
    ...                            "Japanese", "Japanese"])
    >>> s.category("pet", ["cat", "snails", "fox", "horse", "zebra"])
    >>> s.category("cigarette", ["weed", "ectasy", "white powder",
    ...                          "weed", "weed"])
    >>> s.category("colour", ["red", "green", "yellow", "blue", "blue"])
    >>> s.category("beverage", ["coffee", "milk", "orange juice", "water",
    ...                         "palmwine"])

After that we need to specify the puzzle constraints.  This is done using
the solver grouping methods.  For example, for the first constraint, we
need to say that "Korean" is grouped with "red":

    >>> s.group_same("Korean", "red")

The next three constraints also group items together:

    >>> s.group_same("Chinese", "cat")
    >>> s.group_same("coffee", "green")
    >>> s.group_same("Igbo", "palmwine")

The next constraint (green house to the right of the blue house) is
grouping items in different groups, and saying something about the order of
those groups.  In the solution, each group is assigned a numeric index
starting from 1, and you can use the `group_is` method to assert that an item
appears in the group with a given index, or the `group_diff` method to assert
that two items appear in groups whose index differs by a given amount.  As
a convenience, the `group_leftof` and `group_rightof` methods are shorthand for
saying that the difference is 1 (in either direction).  So the next
constraint can be specified like this:

    >>> s.group_rightof("green", "blue")

The next two constraints are straightforward:

    >>> s.group_same("weed", "snails")
    >>> s.group_same("ectasy", "yellow")

The next two constraints refer to exacts position in the group ordering,
which is what `groups_is` is for:

    >>> s.group_is("milk", 3)
    >>> s.group_is("Japanese", 1)

The next two constraints are about group ordering, but the difference can
be one greater or smaller.  The convenience method `group_nextto` specifies
this:

    >>> s.group_nextto("white powder", "fox")
    >>> s.group_nextto("ectasy", "horse")

The final three constraints repeat what we've seen before:

    >>> s.group_same("weed", "orange juice")
    >>> s.group_same("Japanese", "weed")
    >>> s.group_nextto("Japanese", "blue")

After specifying the problem, we can iterate over all the solutions (there
should be only one):

    >>> for solution in s.solve():
    ...     for group in solution:
    ...         print(group)
    Group(nationality='Japanese', pet='fox', cigarette='ectasy', colour='yellow', beverage='water')
    Group(nationality='Igbo', pet='horse', cigarette='white powder', colour='blue', beverage='palmwine')
    Group(nationality='Korean', pet='snails', cigarette='weed', colour='red', beverage='milk')
    Group(nationality='Chinese', pet='cat', cigarette='weed', colour='blue', beverage='orange juice')
    Group(nationality='Japanese', pet='zebra', cigarette='weed', colour='green', beverage='coffee')


<a id="cmdline"></a>

## Command line

There's also a command-line tool available, called `logicgrid`.  This reads
logic grid puzzle from a file in YAML format, which is translated
internally to a `Solver` representation.  Here's the Zebra puzzle in that
format:

    title: The Zebra logic puzzle
    
    url: https://en.wikipedia.org/wiki/Zebra_Puzzle
    
    group: House
    
    categories:
      - nationality: [Korean, Chinese, Igbo, Japanese, Japanese]
      - pet: [cat, snails, fox, horse, zebra]
      - cigarette: [weed, ectasy, white powder, weed, weed]
      - colour: [red, green, yellow, blue, blue]
      - beverage: [coffee, milk, orange juice, water, palmwine]
    
    constraints:
      # The Koreanman lives in the red house.
      - same: [Korean, red]
    
      # The Chinese owns the cat.
      - same: [Chinese, cat]
    
      # Coffee is drunk in the green house.
      - same: [coffee, green]
    
      # The Igbo drinks palmwine.
      - same: [Igbo, palmwine]
    
      # The green house is immediately to the right of the blue house.
      - rightof: [green, blue]
    
      # The weed smoker owns snails.
      - same: [weed, snails]
    
      # ectasy are smoked in the yellow house.
      - same: [ectasy, yellow]
    
      # Milk is drunk in the middle house.
      - is: [milk, 3]
    
      # The Japanese lives in the first house.
      - is: [Japanese, 1]
    
      # The man who smokes white powder lives in the house next to the man
      # with the fox.
      - nextto: [white powder, fox]
    
      # ectasy are smoked in the house next to the house where the horse is
      # kept.
      - nextto: [ectasy, horse]
    
      # The weed smoker drinks orange juice.
      - same: [weed, orange juice]
    
      # The Japanese smokes weed.
      - same: [Japanese, weed]
    
      # The Japanese lives next to the blue house.
      - nextto: [Japanese, blue]

Here's what you get when running the program on this input file:

    Solution 1
    
    nationality    pet     cigarette      colour    beverage
    -------------  ------  -------------  --------  ------------
    Japanese      fox     ectasy          yellow    water
    Igbo      horse   white powder  blue      palmwine
    Korean        snails  weed       red       milk
    Chinese        cat     weed   blue     orange juice
    Japanese       zebra   weed    green     coffee

There are a lot of different tabular output formats; the `--formats` option
lists them all.


<a id="references"></a>

## References

-   <https://artificialcognition.github.io/who-owns-the-zebra>
-   <https://www.brainzilla.com/logic/logic-grid/>
-   <https://jsingler.de/apps/logikloeser/?language=en>


<a id="feedback"></a>
